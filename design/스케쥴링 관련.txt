좋은 아이디어입니다! 스케줄링 기능을 추가하면 자동화가 훨씬 강력해질 것 같네요. 큰 틀을 설계해보겠습니다.

[1 tool called]

## 🕐 시간 예약 실행 시스템 큰 틀

### **1. 전체 아키텍처**
```
⏰ 스케줄링 시스템
├── 스케줄 설정 UI (시간, 반복 설정)
├── 스케줄러 엔진 (백그라운드 실행)
├── 스케줄 저장소 (JSON/SQLite)
├── 실행 큐 관리자
└── 알림 시스템
```

---

## 📋 핵심 컴포넌트 설계

### **A. 스케줄 설정 UI**

#### **1) 메인 화면 추가 요소**
- **🕒 Schedule 탭**: 기존 Execute 버튼 옆에 Schedule 버튼 추가
- **📅 스케줄 목록**: 예약된 작업들 리스트 뷰
- **⚙️ 스케줄 관리**: 추가/편집/삭제/활성화/비활성화

#### **2) 스케줄 설정 다이얼로그**
```
📝 스케줄 설정 폼
├── 작업 이름 (사용자 지정)
├── 실행할 번들/명령어 (현재 선택된 것)
├── 실행 시간 설정
│   ├── 날짜 선택 (DatePicker)
│   ├── 시간 선택 (TimePicker)
│   └── 반복 옵션 (일회성/매일/매주/매월)
├── 고급 옵션
│   ├── 윈도우 선택 (어떤 윈도우에서 실행)
│   ├── 실행 조건 (윈도우가 활성화된 경우만)
│   └── 실패 시 재시도 설정
└── 알림 설정 (실행 전 알림, 완료 알림)
```

#### **3) 반복 실행 옵션**
- **일회성**: 지정된 날짜/시간에 한 번만
- **매일**: 매일 지정된 시간에
- **매주**: 특정 요일 + 시간
- **매월**: 특정 날짜 + 시간  
- **간격**: N분/시간/일마다
- **커스텀**: cron 표현식 지원

---

### **B. 스케줄러 엔진**

#### **1) 백그라운드 실행 구조**
```
🔄 스케줄러 아키텍처
├── SchedulerEngine (메인 스케줄러)
├── TaskQueue (실행 대기 큐)
├── ExecutionWorker (실행 스레드)
├── NotificationManager (알림 관리)
└── ScheduleChecker (1분마다 체크)
```

#### **2) 실행 로직**
- **스케줄 체크**: 1분마다 실행할 작업 확인
- **작업 큐**: 실행할 작업들을 큐에 추가
- **순차 실행**: 하나씩 순서대로 실행 (충돌 방지)
- **상태 추적**: 실행 중/성공/실패 상태 관리
- **로그 기록**: 실행 이력 저장

#### **3) 실행 조건 체크**
- **윈도우 상태**: 지정된 윈도우가 활성화되어 있는지
- **시스템 상태**: PC가 잠금/절전 상태가 아닌지  
- **앱 상태**: 메인 앱이 실행 중인지
- **리소스**: 다른 작업이 실행 중이 아닌지

---

### **C. 데이터 저장 및 관리**

#### **1) 스케줄 데이터 구조**
```json
{
  "schedules": [
    {
      "id": "uuid",
      "name": "아침 게임 자동 실행",
      "bundle_name": "게임시작_번들",
      "commands": ["runapp folder ...", "wait 5", "click 500 300"],
      "schedule": {
        "type": "daily", // once, daily, weekly, monthly, interval
        "time": "09:00",
        "days": [1,2,3,4,5], // 월-금 (weekly의 경우)
        "date": "2024-10-20", // once의 경우
        "interval_minutes": 60 // interval의 경우
      },
      "options": {
        "window_required": "Game",
        "retry_count": 3,
        "retry_delay": 60,
        "notify_before": 300, // 5분 전 알림
        "notify_after": true
      },
      "status": {
        "enabled": true,
        "last_run": "2024-10-16 09:00:00",
        "next_run": "2024-10-17 09:00:00",
        "success_count": 15,
        "fail_count": 2
      }
    }
  ]
}
```

#### **2) 저장 방식**
- **파일**: `schedules.json` (기존 번들과 같은 폴더)
- **백업**: 자동 백업 기능 (일주일치)
- **동기화**: 실시간 저장 (변경 즉시 저장)

---

### **D. 사용자 인터페이스 통합**

#### **1) 메인 화면 개선**
```
🖥️ 메인 UI 레이아웃 확장
├── 기존 영역 (윈도우 선택, 명령어 리스트, 실행)
├── 새로운 Schedule 섹션
│   ├── "Schedule Execute" 버튼
│   ├── 활성 스케줄 개수 표시
│   └── 다음 실행 예정 시간 표시
└── 스케줄 관리 메뉴
    ├── Schedule Manager (별도 창)
    ├── Schedule History (실행 이력)
    └── Schedule Settings (전역 설정)
```

#### **2) 상태 표시 시스템**
- **시스템 트레이**: 스케줄 실행 중 트레이 아이콘 표시
- **알림**: Windows 토스트 알림으로 실행 전후 알림
- **진행률**: 스케줄 실행 중 진행 상황 표시
- **로그 뷰어**: 실행 이력과 오류 로그 확인

---

## ⚙️ 기술 구현 방향

### **스케줄링 라이브러리**
- **APScheduler**: Python 고급 스케줄링 라이브러리
- **threading.Timer**: 간단한 지연 실행
- **time/datetime**: 시간 계산 및 비교

### **UI 컴포넌트**
- **QDateTimeEdit**: PyQt5 날짜/시간 선택기
- **QTimer**: 주기적 스케줄 체크
- **QSystemTrayIcon**: 백그라운드 실행 표시
- **QNotification**: 시스템 알림

### **데이터 관리**
- **JSON**: 설정 파일 저장
- **SQLite**: 실행 이력 저장 (선택사항)
- **threading.Lock**: 동시 접근 제어

---

## 🔄 실행 플로우 예시

### **스케줄 등록 과정**
```
1. 사용자가 명령어 리스트 설정
2. "Schedule Execute" 버튼 클릭  
3. 스케줄 설정 다이얼로그 열기
4. 시간/반복 옵션 설정
5. 스케줄 저장 및 활성화
```

### **자동 실행 과정**  
```
1. 백그라운드에서 1분마다 스케줄 체크
2. 실행 시간 도달 시 실행 큐에 추가
3. 실행 조건 확인 (윈도우 상태 등)
4. 명령어 실행 (기존 execute 로직 재사용)
5. 결과 로깅 및 다음 실행 시간 계산
```

---

## 🎯 추가 고려사항

### **사용자 편의성**
- **Quick Schedule**: "10분 후 실행", "1시간 후 실행" 버튼
- **Template**: 자주 사용하는 스케줄 템플릿 저장
- **Batch**: 여러 스케줄 한번에 설정

### **안정성**
- **실행 충돌 방지**: 동시에 여러 스케줄 실행 금지
- **예외 처리**: 스케줄 실행 실패 시 복구
- **시스템 복구**: 앱 재시작 시 스케줄 상태 복구

이렇게 구현하면 **강력하고 유연한 자동화 스케줄링 시스템**이 될 것 같습니다! 🚀